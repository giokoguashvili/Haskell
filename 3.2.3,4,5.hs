module Demo where
import Data.Char

{-
Напишите функцию readDigits, принимающую строку и возвращающую пару строк.
Первый элемент пары содержит цифровой префикс исходной строки, а второй - ее оставшуюся часть.
GHCi> readDigits "365ads"
("365","ads")
GHCi> readDigits "365"
("365","")
В решении вам поможет функция isDigit из модуля Data.Char.
-}

readDigits :: String -> (String, String)
readDigits = span Data.Char.isDigit

{-
Реализуйте функцию filterDisj, принимающую два унарных предиката и список, и возвращающую список элементов, удовлетворяющих хотя бы одному из предикатов.

GHCi> filterDisj (< 10) odd [7,8,10,11,12]
[7,8,11]
-}
filterDisj :: (a -> Bool) -> (a -> Bool) -> [a] -> [a]
filterDisj p1 p2 = filter (\x -> p1 x || p2 x)

{-
Напишите реализацию функции qsort. Функция qsort должная принимать на вход список элементов и сортировать его в порядке возрастания с помощью сортировки Хоара: для какого-то элемента x изначального списка (обычно выбирают первый) делить список на элементы меньше и не меньше x, и потом запускаться рекурсивно на обеих частях.

GHCi> qsort [1,3,2,5]
[1,2,3,5]
Разрешается использовать только функции, доступные из библиотеки Prelude.
-}
qsort' :: Ord a => [a] -> [a]
qsort' [] = []
qsort' [a] = [a]
qsort' as = 
    let h = head as 
    in
        qsort' (filter (< h) as) ++ (filter (== h) as) ++ qsort' (filter (> h) as)